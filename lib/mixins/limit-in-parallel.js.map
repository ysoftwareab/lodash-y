{"version":3,"sources":["../../src/mixins/limit-in-parallel.ts"],"names":[],"mappings":"mKAAA,wD;;;;;;;;AAQA;AACA,IAAI,aAAa,GAAG,MAAM,CAAC,cAAP,CAAsB,kBAAiB,CAAE,UAAY,CAArD,EAAuD,WAA3E;;AAEA;sCACO,MAAM,oBAAN,SAAmC,KAAnC,CAAyC,E;;;;;;;;AAQhD;;AAEA;;;;;;;;;;;AAWA;AACO,IAAI,eAAe,GAAG;;AAE3B,MAF2B,EAEhB,OAGZ;;;AAAG,EALyB,EAKqD;AAChF,kBAAE,QAAF,CAAW,OAAX,EAAoB;AAClB,IAAA,KAAK,EAAE,CADW;AAElB,IAAA,QAAQ,EAAE,KAFQ,EAApB;;AAIA,MAAI,WAAW,GAAG,CAAlB;;AAEA;AACA,MAAI,MAAM,iCAAV,EAAqC;AACnC,QAAI,EAAE,GAAG,gBAAe,GAAG,IAAlB,EAAmG;AAC1G,UAAI,WAAW,IAAI,OAAO,CAAC,KAA3B,EAAkC;AAChC,YAAI,GAAG,GAAG,IAAI,oBAAJ,CAA0B,sCAAqC,OAAO,CAAC,KAAM,qBAA7E,CAAV;AACA,YAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,gBAAM,GAAN;AACD;AACD,eAAO,GAAP;AACD;AACD,MAAA,WAAW,GAAG,WAAW,GAAG,CAA5B;;AAEA,UAAI,MAAJ;AACA,UAAI,GAAJ;AACA,UAAI;AACF,QAAA,MAAM,4CAAG,MAAM,MAAM,CAAC,GAAG,IAAJ,CAAf,4IAAN;AACD,OAFD,CAEE,OAAO,IAAP,EAAa;AACb,QAAA,GAAG,GAAG,IAAN;AACD,OAJD,SAIU;AACR,QAAA,WAAW,GAAG,WAAW,GAAG,CAA5B;AACD;;AAED,UAAI,CAAC,gBAAE,WAAF,CAAc,GAAd,CAAL,EAAyB;AACvB,cAAM,GAAN;AACD;AACD,aAAO,MAAP;AACD,KAxBD;AAyBA;AACA,WAAO,EAAP;AACD;;AAED,MAAI,EAAE,GAAG,UAAS,GAAG,IAAZ,EAAmE;AAC1E,QAAI,WAAW,IAAI,OAAO,CAAC,KAA3B,EAAkC;AAChC,UAAI,GAAG,GAAG,IAAI,oBAAJ,CAA0B,sCAAqC,OAAO,CAAC,KAAM,qBAA7E,CAAV;AACA,UAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,cAAM,GAAN;AACD;AACD,aAAO,GAAP;AACD;AACD,IAAA,WAAW,GAAG,WAAW,GAAG,CAA5B;;AAEA,QAAI,MAAJ;AACA,QAAI,GAAJ;AACA,QAAI;AACF,MAAA,MAAM,GAAG,MAAM,CAAC,GAAG,IAAJ,CAAf;AACD,KAFD,CAEE,OAAO,IAAP,EAAa;AACb,MAAA,GAAG,GAAG,IAAN;AACD,KAJD,SAIU;AACR,MAAA,WAAW,GAAG,WAAW,GAAG,CAA5B;AACD;;AAED,QAAI,CAAC,gBAAE,WAAF,CAAc,GAAd,CAAL,EAAyB;AACvB,YAAM,GAAN;AACD;AACD,WAAO,MAAP;AACD,GAxBD;AAyBA;AACA,SAAO,EAAP;AACD,CAtEM,C","file":"limit-in-parallel.js","sourcesContent":["import _ from 'lodash';\n\nimport {\n  Fn,\n  FnChangeReturnType,\n  PromiseType\n} from '../types';\n\n// eslint-disable-next-line firecloud/underscore-prefix-non-exported, @typescript-eslint/explicit-function-return-type\nlet AsyncFunction = Object.getPrototypeOf(async function() { /* noop */ }).constructor;\n\n// useful for checks like `err instanceof _.LimitInParallelError`\nexport class LimitInParallelError extends Error {\n}\n\nexport interface LimitInParallelOptions {\n  limit?: number;\n  throwErr?: boolean;\n}\n\n// TODO is there a way not to duplicate the function just because origFn is sync or async?\n\n/**\n * Part of `lodash-firecloud`.\n *\n * Create a function that can only run maximum n times in parallel.\n *\n * @param origFn The function to have its parallelism limited.\n * @param options The options.\n * @param [options.limit=1] Specifies the maximum number of parallel executions.\n * @param [options.throwErr=false] Specifies whether to throw an error when the limit has been reached.\n * @returns Returns the new limited function.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, @typescript-eslint/explicit-function-return-type\nexport let limitInParallel = function<\n  T extends Fn\n>(origFn: T, options: {\n  limit?: number;\n  throwErr?: boolean;\n} = {}): FnChangeReturnType<T, PromiseType<ReturnType<T>> | LimitInParallelError> {\n  _.defaults(options, {\n    limit: 1,\n    throwErr: false\n  });\n  let activeCount = 0;\n\n  // eslint-disable-next-line no-undef\n  if (origFn instanceof AsyncFunction) {\n    let fn = async function(...args: Parameters<T>): Promise<PromiseType<ReturnType<T>> | LimitInParallelError> {\n      if (activeCount >= options.limit) {\n        let err = new LimitInParallelError(`Can only run this function maximum ${options.limit} times in parallel.`);\n        if (options.throwErr) {\n          throw err;\n        }\n        return err;\n      }\n      activeCount = activeCount + 1;\n\n      let result;\n      let err;\n      try {\n        result = await origFn(...args);\n      } catch (err2) {\n        err = err2;\n      } finally {\n        activeCount = activeCount - 1;\n      }\n\n      if (!_.isUndefined(err)) {\n        throw err;\n      }\n      return result;\n    };\n    // @ts-ignore\n    return fn;\n  }\n\n  let fn = function(...args: unknown[]): ReturnType<T> | LimitInParallelError {\n    if (activeCount >= options.limit) {\n      let err = new LimitInParallelError(`Can only run this function maximum ${options.limit} times in parallel.`);\n      if (options.throwErr) {\n        throw err;\n      }\n      return err;\n    }\n    activeCount = activeCount + 1;\n\n    let result;\n    let err;\n    try {\n      result = origFn(...args);\n    } catch (err2) {\n      err = err2;\n    } finally {\n      activeCount = activeCount - 1;\n    }\n\n    if (!_.isUndefined(err)) {\n      throw err;\n    }\n    return result;\n  };\n  // @ts-ignore\n  return fn;\n};\n"]}